// //go:build ignore
// // +build ignore

package main

import (
	"bytes"
	"google.golang.org/protobuf/reflect/protoreflect"
	"os"
	"server/pkg/pb"
	"server/pkg/pb/msgid"
	"sort"
	"strings"
	"text/template"
)

//go:generate go run $GOFILE

type MsgIDInfo struct {
	Max    int32
	EnumId map[string]int32
}

var (
	msgIDs   = make(map[string]*MsgIDInfo)
	fileList = []protoreflect.FileDescriptor{
		pb.File_msg_base_proto,
		pb.File_msg_proto,
		pb.File_msg_player_proto,
		pb.File_msg_server_proto,
	}
)

func init() {
	msgIDs["C2S"] = &MsgIDInfo{EnumId: msgid.MsgIDC2S_value}
	msgIDs["S2C"] = &MsgIDInfo{EnumId: msgid.MsgIDS2C_value}
	msgIDs["S2S"] = &MsgIDInfo{EnumId: msgid.MsgIDS2S_value}
	for _, info := range msgIDs {
		for _, v := range info.EnumId {
			if info.Max < v {
				info.Max = v
			}
		}
	}
}

func main() {
	buildMsgID()
}

func buildMsgID() {
	for k, _ := range msgIDs {
		readProto(k)
		makeMsgIDFile(k)
	}
}

func readProto(typ string) {
	// 获取文件描述符
	info := msgIDs[typ]
	if info == nil {
		panic("can not find type " + typ)
	}
	for _, fd := range fileList {
		// 遍历所有消息类型
		messages := fd.Messages()
		for i := 0; i < messages.Len(); i++ {
			msgName := string(messages.Get(i).Name())
			if strings.HasPrefix(msgName, typ) {
				if _, ok := info.EnumId[msgName]; !ok {
					info.Max++
					info.EnumId[msgName] = info.Max
				}
			}
		}
	}
}

func makeMsgIDFile(typ string) {
	outFileName := "msg_id_" + strings.ToLower(typ) + ".proto"
	tmpl, err := template.New("msgid_" + typ + ".proto").Parse(`// Code generated by tools/proto/build.go.
syntax = "proto3";
option optimize_for = LITE_RUNTIME;
option go_package = "./msgid";
package msgid;

// Client向Server发送消息
enum MsgID{{.EName}}
{
	{{range $i, $v := .Node}} {{$v.Name}}	= {{$v.Value}};
	{{end}}
};`)
	if err != nil {
		panic(err)
	}
	info := msgIDs[typ]
	if info == nil {
		panic("can not find type " + typ)
	}
	type node struct {
		Name  string
		Value int32
	}
	type TempData struct {
		Node  []*node
		EName string
	}
	target := make([]*node, 0)
	for k, v := range info.EnumId {
		target = append(target, &node{Name: k, Value: v})
	}
	sort.Slice(target, func(i, j int) bool {
		return target[i].Value < target[j].Value
	})

	buff := bytes.NewBuffer(nil)
	if err = tmpl.Execute(buff, &TempData{Node: target, EName: typ}); err != nil {
		panic(err)
	}
	if err = os.WriteFile(outFileName, buff.Bytes(), os.ModePerm); err != nil {
		panic(err)
	}
}
